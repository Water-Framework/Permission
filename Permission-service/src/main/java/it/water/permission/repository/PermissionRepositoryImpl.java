package it.water.permission.repository;

import it.water.core.api.action.ResourceAction;
import it.water.core.api.model.Resource;
import it.water.core.interceptors.annotations.FrameworkComponent;
import it.water.permission.api.PermissionRepository;
import it.water.permission.model.WaterPermission;
import it.water.repository.entity.model.exceptions.NoResultException;
import it.water.repository.jpa.WaterJpaRepositoryImpl;
import jakarta.transaction.Transactional;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.*;


/**
 * @Generated by Water Generator
 * Repository Class for Permission entity.
 */
@FrameworkComponent
public class PermissionRepositoryImpl extends WaterJpaRepositoryImpl<WaterPermission> implements PermissionRepository {
    private static Logger log = LoggerFactory.getLogger(PermissionRepositoryImpl.class);
    private static final String PERMISSION_PERSISTENCE_UNIT = "permission-persistence-unit";
    private static final String ENTITY_RESOURCE_FIELD_NAME = "entityResourceName";
    private static final String ROLE_ID_FIELD_NAME = "roleId";

    public PermissionRepositoryImpl() {
        super(WaterPermission.class, PERMISSION_PERSISTENCE_UNIT);
    }

    /**
     * Find a permission by a specific user and resource
     *
     * @param userId   user parameter
     * @param resource parameter required to find a resource
     * @return Permission if found
     */
    @Override
    public WaterPermission findByUserAndResource(long userId, Resource resource) {
        log.debug("invoking findByRoleAndResource User: {} Resource: {}", userId, resource.getResourceName());
        return this.findByUserAndResourceName(userId, resource.getResourceName());
    }

    /**
     * Find a permission by a specific user and resource name via query
     *
     * @param userId             user parameter
     * @param entityResourceName parameter required to find a resource name
     * @return Permission if found
     */
    @Override
    public WaterPermission findByUserAndResourceName(long userId, String entityResourceName) {
        log.debug("invoking findByUserAndResourceName User: {} Resource: {}", userId, entityResourceName);
        return tx(jakarta.transaction.Transactional.TxType.REQUIRED, entityManager -> {
            WaterPermission p = null;
            try {
                p = entityManager.createQuery(
                                "from WaterPermission p where p.userId = :userId and roleId = 0 and p.entityResourceName = :entityResourceName and p.resourceId = 0",
                                WaterPermission.class).setParameter("userId", userId)
                        .setParameter(ENTITY_RESOURCE_FIELD_NAME, entityResourceName).getSingleResult();
            } catch (NoResultException e) {
                log.debug(e.getMessage(), e);
            }
            return p;
        });
    }

    /**
     * Find a permission by a specific user, resource name and resource id via query
     *
     * @param userId             user parameter
     * @param entityResourceName parameter required to find a resource name
     * @param id                 parameter required to find a resource id
     * @return Permission if found
     */
    @Override
    public WaterPermission findByUserAndResourceNameAndResourceId(long userId,
                                                                  String entityResourceName, long id) {
        log.debug("invoking findByUserAndResourceNameAndResourceId User: {}", userId);
        return tx(Transactional.TxType.REQUIRED, entityManager ->
                entityManager.createQuery(
                                "from WaterPermission p where p.userId = :userId and roleId = 0 and p.entityResourceName = :entityResourceName and p.resourceId = :id",
                                WaterPermission.class).setParameter("userId", userId)
                        .setParameter(ENTITY_RESOURCE_FIELD_NAME, entityResourceName).setParameter("id", id)
                        .getSingleResult()
        );
    }

    /**
     * Find a permission by a specific role and resource
     *
     * @param roleId   parameter required to find role by roleId
     * @param resource parameter required to find a resource
     * @return Permission if found
     */
    @Override
    public WaterPermission findByRoleAndResource(long roleId, Resource resource) {
        log.debug("invoking findByRoleAndResource Role: {} Resource: {}", roleId, resource.getResourceName());
        return this.findByRoleAndResourceName(roleId, resource.getResourceName());
    }

    /**
     * Find a permission by a specific role and resource name via query
     *
     * @param roleId             parameter required to find role by roleId
     * @param entityResourceName parameter required to find a resource name
     * @return Permission if found
     */
    @Override
    public WaterPermission findByRoleAndResourceName(long roleId, String entityResourceName) {
        log.debug("invoking findByRoleAndResourceName Role: {} Resource: {}", roleId, entityResourceName);
        return tx(Transactional.TxType.REQUIRED, entityManager -> {
            WaterPermission p = null;
            try {
                p = entityManager.createQuery(
                                "from WaterPermission p where p.roleId = :roleId and userId = 0 and p.entityResourceName = :entityResourceName and p.resourceId = 0",
                                WaterPermission.class).setParameter(ROLE_ID_FIELD_NAME, roleId)
                        .setParameter(ENTITY_RESOURCE_FIELD_NAME, entityResourceName).getSingleResult();
            } catch (NoResultException | jakarta.persistence.NoResultException e) {
                log.debug(e.getMessage(), e);
            }
            return p;
        });
    }

    /**
     * Find permissions by a specific role
     *
     * @param roleId parameter required to find role by roleId
     * @return Permissions if found
     */
    @Override
    public Collection<WaterPermission> findByRole(long roleId) {
        log.debug("invoking findByRoleAndResourceName Role: {}", roleId);
        return tx(Transactional.TxType.REQUIRED, entityManager ->
                entityManager
                        .createQuery("from WaterPermission p where p.roleId = :roleId and userId = 0",
                                WaterPermission.class)
                        .setParameter(ROLE_ID_FIELD_NAME, roleId).getResultList()
        );
    }


    /**
     * Find a permission by a specific role, resource name and resource id via query
     *
     * @param roleId             parameter required to find role by roleId
     * @param entityResourceName parameter required to find a resource name
     * @param id                 parameter required to find a resource id
     * @return Permission if found
     */
    @Override
    public WaterPermission findByRoleAndResourceNameAndResourceId(long roleId,
                                                                  String entityResourceName, long id) {
        log.debug("invoking findByRoleAndResourceNameAndResourceId Role: {}", roleId);
        return tx(Transactional.TxType.REQUIRED, entityManager -> entityManager.createQuery("from WaterPermission p where p.roleId = :roleId and userId = 0 and p.entityResourceName = :entityResourceName and p.resourceId = :id", WaterPermission.class).setParameter(ROLE_ID_FIELD_NAME, roleId).setParameter(ENTITY_RESOURCE_FIELD_NAME, entityResourceName).setParameter("id", id).getSingleResult());
    }

    /**
     * Checks if  default "RegisteredUser" role exists, and, if not, creates it.
     */
    public void checkOrCreatePermissions(long roleId, List<ResourceAction<?>> actions) {
        txExpr(Transactional.TxType.REQUIRED, entityManager -> {
            HashMap<String, Long> actionsIds = new HashMap<>();
            HashMap<String, WaterPermission> existingPermissions = new HashMap<>();


            //calculating pairs resourceName - actionsIds
            for (int i = 0; i < actions.size(); i++) {
                ResourceAction<?> action = actions.get(i);
                String resourceClassName = action.getResourceClass().getName();
                //Checks if permission already exists for that resource
                WaterPermission p = this.findByRoleAndResourceName(roleId, action.getResourceClass().getName());
                if (p == null)
                    log.debug("No permission found for resource: {} and role {}", resourceClassName, roleId);
                else
                    existingPermissions.put(resourceClassName, p);

                // create pair <resourceName, actionId> if resourceName does not exist, sum actionId otherwise
                actionsIds.merge(resourceClassName, action.getAction().getActionId(), (existing, toAdd) -> existing | toAdd);
            }

            checkOrCreatePermission(actionsIds, existingPermissions, roleId, 0L);
        });
    }

    /**
     * Check if role exist :
     * 1)if not exist create role with permission to specific Entity
     * 2)if exist search if role's permission must be updated
     * The permission associated is relative to a specific entity.
     */
    @Override
    public void checkOrCreatePermissionsSpecificToEntity(long roleId, long entityId, List<ResourceAction<?>> actions) {
        txExpr(Transactional.TxType.REQUIRED, entityManager -> {
            HashMap<String, Long> actionsIds = new HashMap<>();
            HashMap<String, WaterPermission> existingPermissions = new HashMap<>();

            //calculating pairs resourceName - actionsIds
            for (int i = 0; i < actions.size(); i++) {
                ResourceAction<?> resAction = actions.get(i);
                //Checks if permission already exists for that resource
                WaterPermission p = this.findByRoleAndResourceNameAndResourceIdInTransaction(roleId, resAction.getResourceClass().getName(), entityId);
                if (p == null)
                    log.debug("No permission found for resource: {} with id {} and role {}", resAction.getResourceClass().getName(), entityId, roleId);
                else
                    existingPermissions.put(resAction.getResourceClass().getName(), p);

                // create pair <resourceName, actionId> if resourceName does not exist, sum actionId otherwise
                actionsIds.merge(resAction.getResourceClass().getName(), resAction.getAction().getActionId(), (existing, toAdd) -> existing | toAdd);
            }
            checkOrCreatePermission(actionsIds, existingPermissions, roleId, entityId);

        });
    }

    @Override
    public boolean permissionSpecificToEntityExists(String resourceName, long resourceId) {
        if (resourceId == 0) {
            return false;
        }
        return tx(Transactional.TxType.REQUIRED, entityManager -> {
            String query = "SELECT COUNT(p) from WaterPermission p where p.entityResourceName = :entityResourceName and p.resourceId = :resourceId";
            Number number = (Number) entityManager
                    .createQuery(query)
                    .setParameter(ENTITY_RESOURCE_FIELD_NAME, resourceName)
                    .setParameter("resourceId", resourceId)
                    .getSingleResult();
            return number.longValue() > 0;
        });
    }

    /**
     * This method works like findByRoleAndResourceNameAndResourceId but with the exception that
     * the NoResultException is catch internally to the transaction such that transaction's rollback doesn't happen.
     * Method is visibility is public such that the method is called in a transactional context.
     * This method is used only for internal execution.
     * This method isn't part of the OSGI service interface
     */
    public WaterPermission findByRoleAndResourceNameAndResourceIdInTransaction(long roleId,
                                                                               String entityResourceName, long id) {
        log.debug("invoking findByRoleAndResourceNameAndResourceIdInTransaction Role: {}," +
                "entityResourceName {} , entityId {}", roleId, entityResourceName, id);
        return tx(Transactional.TxType.REQUIRED, entityManager -> {
            WaterPermission p = null;
            try {
                p = entityManager.createQuery(
                                "from WaterPermission p where p.roleId = :roleId and p.entityResourceName = :entityResourceName and p.resourceId = :id",
                                WaterPermission.class).setParameter(ROLE_ID_FIELD_NAME, roleId)
                        .setParameter(ENTITY_RESOURCE_FIELD_NAME, entityResourceName).setParameter("id", id)
                        .getSingleResult();
            } catch (NoResultException e) {
                log.debug(e.getMessage(), e);
            }
            return p;
        });
    }

    /**
     * Method is visibility is public such that the method is called in a transactional context.
     * This method is used only for internal execution.
     * This method isn't part of the OSGI service interface
     */
    public void checkOrCreatePermission(Map<String, Long> actionIdsByResource, Map<String, WaterPermission> existingPermissions, long roleId, long entityId) {

        txExpr(Transactional.TxType.REQUIRED, entityManager -> {

            // actionIdsByResource contain the value(actionIds)for each resource like-> Book actions = {CrudActions.FIND,CrudActions.FIND_ALL}),
            Iterator<String> it = actionIdsByResource.keySet().iterator();
            while (it.hasNext()) {
                String resourceName = it.next();
                long actionIdsToAdd  = actionIdsByResource.get(resourceName);
                WaterPermission permissionToSave  = null;
                boolean mustUpdate = false;
                boolean isUnchanged = false;
                String permissionName = resourceName + " Permissions";
                WaterPermission existingPermission = existingPermissions.get(resourceName);

                // If no permission exists for this resource, create a new one
                if (existingPermission == null) {
                    permissionToSave  = new WaterPermission(permissionName, actionIdsToAdd, resourceName, entityId, roleId, 0l);
                }
                // if the permission exists and the actionIds are different, update it
                else {
                    // with OR if you add the value that is already present, the value remains the same
                    long newActionIds = existingPermission.getActionIds() | actionIdsToAdd;
                    // update only if something changed
                    if(newActionIds != existingPermission.getActionIds()) {
                        // update actionIds
                        permissionToSave  = existingPermission.withAccumulateActions(newActionIds);
                        mustUpdate = true;
                    } else {
                        isUnchanged = true;
                    }
                }
                saveOrUpdatePermission(isUnchanged, mustUpdate, permissionToSave);
            }
        });
    }

    private void saveOrUpdatePermission(boolean isUnchanged, boolean mustUpdate, WaterPermission p) {
        if (!isUnchanged) {
            // save or update
            try {
                if (!mustUpdate)
                    this.persist(p);
                else
                    this.update(p);
            } catch (Exception e) {
                log.error(e.getMessage(), e);
            }
        }
    }


}
